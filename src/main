program simulation
  use, intrinsic :: iso_fortran_env
  use precision
  use mpiinterface, only: ThisProc, NumProcs, MPIstop, intmpi, syncall
  use lattice, only: ndim
  use lattice
  use halocomm
  use xpfft
  !use gaugeconfiguration_su3
  use mpi
  use io
  implicit none

  ! Simulation parameters
  integer(int64) :: LatticeExtensions(ndim)!(ndim)
  real(fp)       :: LatticeSpacings(0:ndim)!(0:ndim)
  integer(int64) :: TimeSteps
  integer(int64) :: RandomNumberSeed

  real(fp)   :: GluonSaturationScale !qs
  real(fp)   :: GluonOccupationAmplitude ! Amplitude of box in units of 1/g^2
  real(fp)   :: GluonCoupling
  integer(int64) :: EnsembleSize
  real(fp)   :: Quarkmass
  real(fp)   :: CoMTime
  real(fp)   :: TimeRange
  !real(fp)  :: Wilsoncoeffs(nWilsonCoeffs)

  real(fp) :: GaugefixingCoefficient
  integer(int64) :: Number_of_Measurements_of_Gluondistribution
  integer(int64) :: TimePoints_between_Measurement_of_Gluondistribution
  real(fp) :: TimeBetweenGluonMeasurements
  
  ! Physical fields
  !type(GaugeConfiguration) :: GaugeConf
  
  complex(fp), allocatable :: testcomm(:)

  ! Monitoring variables
  integer(int64) :: it, idistmeas

  integer(int64) :: LocalIndex, LatticeIndex, i
  integer(int64), allocatable :: LocalLatticeIndices(:)
  
  ! MPI
  integer(intmpi) :: mpierr, mpistatus(mpi_status_size), proc, tag, source, dest, buffersize

  real(fp), allocatable :: correlator(:)
  ! Ensemble variables
  real(fp), allocatable :: AA_correlator_ensemble(:,:,:), EE_correlator_ensemble(:,:,:)
  real(fp), allocatable :: AA_correlator(:,:), AA_correlator_stderror(:,:)
  real(fp), allocatable :: EE_correlator(:,:), EE_correlator_stderror(:,:)
  real(fp), allocatable :: GluonDistribution(:,:), GluonDistribution_stderror(:,:)
  real(fp), allocatable :: &
       GluonDistribution_AtTimePoint(:), GluonDistribution_AtTimePoint_stderror(:)
  integer :: iensemble
  real(fp), allocatable :: momenta(:)

  
  ! Output
  integer(int8) :: FileID
  character(len=128) :: filename,time_tag
  
  ! Control observable output (Gauss, Energy)
  integer(int8) :: fileID_eg
  real(fp) :: gauss, energy
  real(fp) :: time

  complex(fp), allocatable :: data(:)
  
  call InitSimulation

  allocate(data(GetMemorySize()))


  call mpistop

  
  allocate(AA_correlator_ensemble(GetLocalLatticeSize(),&
       0:Number_of_Measurements_of_Gluondistribution,EnsembleSize))
  allocate(EE_correlator_ensemble(GetLocalLatticeSize(),&
       0:Number_of_Measurements_of_Gluondistribution,EnsembleSize))
  ensemble: do iensemble=1,EnsembleSize
     if(ThisProc()==0) print*,iensemble

     call GaugeConf%TransversePolarisedOccupiedInit_Box(&
          GluonSaturationScale,GluonOccupationAmplitude,GluonCoupling)

     idistmeas = 0
     call GaugeConf%GetTransverseAACorrelator(correlator)
     AA_correlator_ensemble(:,idistmeas,iensemble) = correlator

     call GaugeConf%GetTransverseEECorrelator(correlator)
     EE_correlator_ensemble(:,idistmeas,iensemble) = correlator
  end do ensemble

  ! ..--** Start: Statistics and output **--..

  it = 0
  call StatisticsCorrelator(AA_correlator_ensemble,AA_correlator,AA_correlator_stderror,0)
  call StatisticsCorrelator(EE_correlator_ensemble,EE_correlator,EE_correlator_stderror,0)

  allocate(GluonDistribution(&
       lbound(AA_correlator,1):ubound(AA_correlator,1),&
       lbound(AA_correlator,2):ubound(AA_correlator,2)))
  allocate(GluonDistribution_stderror(&
       lbound(AA_correlator,1):ubound(AA_correlator,1),&
       lbound(AA_correlator,2):ubound(AA_correlator,2)))

  GluonDistribution = &
                                !AA_correlator
       sqrt(AA_correlator*EE_correlator)
  GluonDistribution_stderror = &
                                !AA_correlator_stderror
       sqrt(&
       + (AA_correlator_stderror*EE_correlator)**2 &
       + (EE_correlator_stderror*AA_correlator)**2&
       )

  ! Collecting data by process 0 and printing to file
  do idistmeas=lbound(GluonDistribution,2),ubound(GluonDistribution,2)
     if(ThisProc()==0) then
        write(filename,"(A18,I0.3,A1,I0.3,A1,I0.3)") 'gluondistribution_', &
             LatticeExtensions(1),'x',LatticeExtensions(2),'x',&
             LatticeExtensions(3)

        time = (idistmeas - lbound(GluonDistribution,2)) &
             * TimeBetweenGluonMeasurements
        write(time_tag,"(F12.3)") time
        time_tag = '_t' // trim(ADJUSTL(time_tag))
        filename = trim(filename) // trim(time_tag) // '.txt'

        fileID = OpenFile(filename=filename,st='REPLACE',fm='FORMATTED',act='WRITE')
     end if
     dest = 0

     
     allocate(Momenta(GetLocalLatticeSize()))

     call GetLocalLatticeIndices_allocatable(LocalLatticeIndices)
     forall(LocalIndex=1:GetLocalLatticeSize())
        Momenta(LocalIndex) = GetNorm2Momentum(LocalLatticeIndices(LocalIndex))
     end forall
     
     do proc=0,NumProcs()-1
        ! Allocate at destination and sending process the buffer for output
        if(ThisProc()==dest .or. ThisProc()==proc) then
           if(allocated(GluonDistribution_AtTimePoint))&
                deallocate(GluonDistribution_AtTimePoint)

           if(allocated(GluonDistribution_AtTimePoint_stderror))&
                deallocate(GluonDistribution_AtTimePoint_stderror)

           allocate(GluonDistribution_AtTimePoint(GetLocalLatticeSize()))
           allocate(GluonDistribution_AtTimePoint_stderror(GetLocalLatticeSize()))
        end if

        if(proc/=dest) then
           source = proc

           buffersize = size(GluonDistribution_atTimePoint)

           if(ThisProc()==proc) then

              ! Sending gluon distribution
              tag = proc
              
              GluonDistribution_AtTimePoint = GluonDistribution(:,idistmeas)
              call mpi_send(GluonDistribution_AtTimePoint,buffersize,MPI_DOUBLE,&
                   dest,tag,&
                   MPI_COMM_WORLD,mpierr)

              ! Sending its standard error
              tag = proc+NumProcs()
              GluonDistribution_AtTimePoint_stderror = GluonDistribution_stderror(:,idistmeas)
              call mpi_send(GluonDistribution_AtTimePoint_stderror,buffersize,MPI_DOUBLE,&
                   dest,tag,&
                   MPI_COMM_WORLD,mpierr)

              ! sending momenta
              tag = proc+2*NumProcs()
              call mpi_send(Momenta,buffersize,MPI_DOUBLE,dest,tag,MPI_COMM_WORLD,mpierr)
           else if(ThisProc()==dest) then
              ! Recieving gluon distribution
              tag = proc
              call mpi_recv(GluonDistribution_AtTimePoint,buffersize,MPI_DOUBLE,&
                   source,tag,&
                   MPI_COMM_WORLD,mpistatus,mpierr)

              ! Recieving its standard error
              tag = proc+NumProcs()
              call mpi_recv(GluonDistribution_AtTimePoint_stderror,buffersize,MPI_DOUBLE,&
                   source,tag,&
                   MPI_COMM_WORLD,mpistatus,mpierr)
              
              ! Recieving momenta
              tag = proc+2*NumProcs()
              call mpi_send(Momenta,buffersize,MPI_DOUBLE,source,tag,MPI_COMM_WORLD,mpistatus,mpierr)
           else
              ! Do nothing
           end if
        elseif(ThisProc()==dest) then
           GluonDistribution_AtTimePoint = GluonDistribution(:,idistmeas)
           GluonDistribution_AtTimePoint_stderror = GluonDistribution_stderror(:,idistmeas)
        end if

        ! Writing step
        if(ThisProc()==dest) then
           do LocalIndex=&
                lbound(GluonDistribution_AtTimePoint,1),&
                ubound(GluonDistribution_AtTimePoint,1)

              !LatticeIndex = GetGlobalLatticeIndex(LocalIndex,proc)
              !if(GetProc(LatticeIndex)==proc) then
              !   print*,ThisProc(),proc,LatticeIndex
              write(fileID,'(3(SP,E13.6,1X))') &
                   Momenta(LocalIndex),&
                   GluonDistribution_AtTimePoint(LocalIndex),&
                   GluonDistribution_AtTimePoint_stderror(LocalIndex)
              !end if
           end do
        end if
        call syncall
     end do
     if(ThisProc()==0) call CloseFile(FileID)
  end do
  ! ..--**  END : Statistics and output **--..

  
  call EndSimulation

contains
  
  !>@brief Initialisation of the simulation
  !!@details
  !! MPI\n
  !! Lattice-module\n
  !! Random number generator\n
  !! etc.
  !!@author Alexander Lehmann, UiS (<alexander.lehmann@uis.no>)
  !! and ITP Heidelberg (<lehmann@thpys.uni-heidelberg.de>)
  !!@date 15.02.2019
  !!@version 1.0
  impure subroutine InitSimulation
    use precision, only: fp
    use, intrinsic :: iso_fortran_env
    
    use mpiinterface,       only: InitModule_MPIinterface       => InitModule, ThisProc, SyncAll
    use lattice,            only: InitModule_Lattice            => InitModule, nDim
    use halocomm,           only: InitModule_HaloComm           => InitModule
    use random,             only: InitModule_Random             => InitModule
    use xpfft,              only: InitModule_xpFFT              => InitModule
    use tolerances,         only: InitModule_tolerances         => InitModule
    implicit none

    integer(int64) :: arg_count
    character(len=80) :: arg
    integer(int8) :: i
    
    !..--** Reading simulation parameters **--..
    arg_count = 0
    
    ! Spatial lattice parameters (extensions, spacings)
    do i=1,ndim
       arg_count = arg_count +1; call get_command_argument(arg_count,arg);
       read(arg,'(I4)') LatticeExtensions(i)
    end do

    do i=0,ndim
       arg_count = arg_count +1; call get_command_argument(arg_count,arg);
       read(arg,'(F10.13)') LatticeSpacings(i)
    end do

    ! Center of mass time T
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(F10.13)') CoMTime
    ! Center of mass time-range smax
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(F10.13)') TimeRange

    TimeSteps=ceiling(TimeRange/LatticeSpacings(0))
    
    ! Seed for random number generator
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(I4)') RandomNumberSeed
    
    ! Initial gluon distribution (box): Saturation scale
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(F10.13)') GluonSaturationScale

    ! Initial gluon distribution (box): Amplitude
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(F10.13)') GluonOccupationAmplitude

    ! Coupling (only relevant in initialisation)
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(F10.13)') GluonCoupling

    ! Ensemble size (statistical average of classical statistical simulation)
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(I6)') EnsembleSize
    
    ! Time between gluon measurements
    arg_count = arg_count +1; call get_command_argument(arg_count,arg);
    read(arg,'(F10.13)') TimeBetweenGluonMeasurements
    Number_of_Measurements_of_Gluondistribution = aint(TimeRange/TimeBetweenGluonMeasurements,int64)
    
    !..--** Module initialisations **--..
    call InitModule_MPIinterface
    call InitModule_Lattice(LatticeExtensions(1:ndim),LatticeSpacings(0:ndim))
    call InitModule_HaloComm
    call InitModule_xpFFT
    call InitModule_Random(RandomNumberSeed + ThisProc())
    call InitModule_tolerances

    call SyncAll
  end subroutine InitSimulation

  !>@brief Ending of the simulation
  !!@author Alexander Lehmann, UiS (<alexander.lehmann@uis.no>)
  !! and ITP Heidelberg (<lehmann@thpys.uni-heidelberg.de>)
  !!@date 15.02.2019
  !!@version 1.0
  subroutine EndSimulation
    use mpiinterface, only: FinalizeModule_MPIinterface => FinalizeModule
    use xpfft,        only: FinalizeModule_xpFFT        => FinalizeModule
    implicit none

    call FinalizeModule_xpFFT
    call FinalizeModule_MPIinterface

    STOP "Simulation completed"
  end subroutine EndSimulation


  pure subroutine StatisticsCorrelator(&
       correlator_ensemble,correlator,correlator_stderror,lbound_time)
    use precision, only: fp
    use statistics, only: GetMean, GetStdError

    implicit none
    real(fp),intent(in) :: correlator_ensemble(:,lbound_time:,:)
    real(fp),allocatable,intent(out):: correlator(:,:)
    real(fp),allocatable,intent(out):: correlator_stderror(:,:)
    integer, intent(in) :: lbound_time

    integer :: latticeindex, it

    allocate(correlator(&
         lbound(correlator_ensemble,1):ubound(correlator_ensemble,1),&
         lbound(correlator_ensemble,2):ubound(correlator_ensemble,2)))

    allocate(correlator_stderror(&
         lbound(correlator_ensemble,1):ubound(correlator_ensemble,1),&
         lbound(correlator_ensemble,2):ubound(correlator_ensemble,2)))

    forall(&
         it          =lbound(correlator_ensemble,2):ubound(correlator_ensemble,2),&
         latticeindex=lbound(correlator_ensemble,1):ubound(correlator_ensemble,1))&
         correlator(latticeindex,it) = GetMean(correlator_ensemble(latticeindex,it,:))

    if(size(correlator_ensemble,3)>1) then
       forall(&
            it          =lbound(correlator_ensemble,2):ubound(correlator_ensemble,2),&
            latticeindex=lbound(correlator_ensemble,1):ubound(correlator_ensemble,1))&
            correlator_stderror(latticeindex,it) = GetStdError(correlator_ensemble(latticeindex,it,:))
    else
       correlator_stderror = 0
    end if
  end subroutine StatisticsCorrelator
end program simulation
